* Visualisierung

In diesem /workflow/ wollen wir unsere Ergebnisse visualisieren, nachdem wir die TM-Analyse durchgeführt haben. Dafür werden wir zwei Möglichkeiten sehen. Die erste Möglichkeit verwendet die Bibliothek Networkx in Python. Die zweite Möglichkeit verwendet die Anwendung Gephi.

** Dieses Workflow als Anwendung benutzen

Wie unsere anderen /workflow/ kann dieses /workflow/ als Anwendung benutzt werden. Erforderlich dafür ist die Installation vom Texteditor Emacs mit Org-mode (ab emacs-28 ist Org-mode mit dem Texteditor geliefert und muss nicht separat installiert werden).

Pfade müssen ggfs. vom Benutzer des Workflows angepasst werden.

Dieses Workflow kann auf der Kommandozeile mit dem folgenden Skript 'graphic-dat.sh' ausgeführt werden. Zuerst stellen wir einen Arbeitsordner her, zu dem wir die Dateien kopieren, die wir im Rahmen von diesem /workflow/ verwenden:

#+name: user-path
#+begin_src shell :var user="/home/cpsoz/TM-WS-25" :results silent
  mkdir $user/TM-Analyse-4
#+end_src

Unsere Analyse wird in diesem Ordner 'TM-Analyse-4' stattfinden. Dort stellen wir einen Ordner 'TM-Skripten' für die Skripten, die wir im Rahmen von diesem /workflow/ schreiben, und wir definieren den vollständigen Pfad zum Ordner 'TM-Analyse-4' als neuen Benutzerpfad (Pfad anpassen):

#+name: nuser
#+begin_src shell :var nuserpath="/home/cpsoz/TM-WS-25/TM-Analyse-4" :results silent
  echo $nuserpath
#+end_src

#+name: tm-skripten
#+begin_src shell :var userpath=nuser :results silent
  mkdir $userpath/TM-Skripten
#+end_src

Dann schreiben wir den 'graphic-dat.sh' Skript wie folgt:

#+begin_src shell :results silent :var user=nuser
  touch $user/graphic-dat.sh
  echo "#!/bin/bash" >> $user/graphic-dat.sh
  echo "emacs /home/cpsoz/Gitub/mta-tutorial/Org/Lecture-8-de.org --batch -l /home/cpsoz/.emacs.d/init.el --eval \"(setq org-confirm-babel-evaluate nil)\" --eval \"(org-babel-execute-buffer)\"" >> $user/graphic-dat.sh
  chmod +x $user/graphic-dat.sh
#+end_src

Dieser Skript führt alle Code-Blöcke in diesem /workflow/ aus. Er kann entsprechend mit bash verwendet werden, wie etwa: bash graphic-dat.sh oder ./graphic-dat.sh. Ohne Bash-Skript kann dieses /worflow/ von einem Terminal mit

~emacs /home/cpsoz/Gitub/mta-tutorial/Org/Lecture-8-de.org --batch -l /home/cpsoz/.emacs.d/init.el --eval "(setq org-confirm-babel-evaluate nil)" --eval "(org-babel-execute-buffer)"~

ausgeführt werden.

Für unsere Übung werden wir die Datei JOBDT.csv aus dem Ordner Stuff5 verwenden. Wir kopieren diese Datei zu unserem Arbeitsordner wie folgt:

#+name: copy-data
#+begin_src shell :var data="/home/cpsoz/Github/mta-tutorial/Stuff5" :var user=nuser :results silent
  cp -r $data/JOBDT.csv $user
#+end_src

* Datensatz - Vorbereitung

Die Datei JOBDT.csv stellt die Liste der Topics mit dem herrschenden Topic für die Dokumente dar, die wir in unserem letzten /workflow/ analysiert haben.

Wir benutzen diese Datei für die Herstellung der Graphiken, aber wir müssen sie anpassen, damit die Verbindungen zwischen den Dokumenten und den Topics in der Form von einer netzwerkartigen Beschreibung dieser Verbindungen erfolgt. Eine solche netzwerkartige Beschreibung setzt grundsätzlich das Folgende voraus:

- Verbindungen zwischen Texte und Topics;
- Verbindungen zwischen den Topics.

Diese Verbindungen sind unterschiedlich wichtig und tragen deshalb dazu bei, dass die Topic je nachdem unterschiedlich wichtig sind, wie viele Verbindungen sie empfangen und wie stark diese Verbindungen zwischen Texten und Topics sind. Dies wollen wir im Folgenden zuerst mit networkx abbilden.

* Networkx Plots

Aus der JOBDT.csv-Datei machen wir eine Kopie dt.csv, mit der wir dann arbeiten werden. Wir entfernen die unbedeutsamen Daten (mit Null-Einträgen) und vereinfachen die Dateinamen für eine bessere Lesbarkeit der Abbildung:

#+begin_src shell :var user=nuser :results silent
  cd $user
  awk -F',' '{$NF=""}1' JOBDT.csv > dt.csv
  sed -i 's/_JOB.*\.txt//g' dt.csv
  sed -i 's/^...._*_//g' dt.csv
  sed -i "s/ /,/g" dt.csv
  sed -i 's/.$//' dt.csv
  sed -i '/,$/d' dt.csv
#+end_src

Wir schreiben einen Code in Python, um die dt.csv Datei umzustrukturieren, und das Ergebnis schreiben wir in eine Datei 'texttopic.txt':

#+begin_src python :file texttopic.txt :dir /home/cpsoz/TM-WS-25/TM-Analyse-4/ :results silent
    csv = open("/home/cpsoz/TM-WS-25/TM-Analyse-4/dt.csv")
    columns = csv.readline().strip().split(',')[1:]
    file=open("texttopic.txt", "w")
    for line in csv:
        tokens = line.strip().split(',')
        row = tokens[0]
        for column, cell in zip(columns,tokens[1:]):
            print('{},{},{}'.format(row,column,cell))
            s = str('{},{},{}'.format(row,column,cell))
            file.write(s + "\n")
    file.close()
#+end_src

Auf der Grundlage von 'texttopic.txt' wollen wir zwei neuen Dateien generieren, und zwar:

- eine Datei für die Knoten vom Netzwerk;
- eine Datei für die Pfeilen zwischen Knoten.

Dies machen wir wie folgt:

#+begin_src shell :results silent :var user=nuser
  cd $user
  sed -e 's/,,/,/g' -e '/,0.0/d' texttopic.txt > ttedge_list.txt
  awk -F',' ' { print $1 "," $1 } ' texttopic.txt | sort | uniq | sed 's/\.txt//' | awk -F',' ' {print $2 "," $1} ' > ttnode_list.txt
  echo "id,label" | cat - ttnode_list.txt > ttnode_list.csv
  echo "source,target,weight" | cat - ttedge_list.txt > ttedge_list.csv

  ### ADD TOPICS at the end of the node file in two columns

  echo "Topic_0,Topic_0" >> ttnode_list.csv
  echo "Topic_1,Topic_1" >> ttnode_list.csv
  echo "Topic_2,Topic_2" >> ttnode_list.csv
  echo "Topic_3,Topic_3" >> ttnode_list.csv

  mv ttedge_list.csv Job-edge.csv && mv ttnode_list.csv Job-node.csv
  rm ttedge_list.txt ttnode_list.txt
#+end_src

Jetzt haben wir unsere Knoten und Pfeilen zwischen diesen Knoten. Wir können mit der Abbildung anfangen:

#+begin_src python  :results Job_network.pdf file
    import matplotlib.cm as cm
    import matplotlib.pyplot as plt
    import matplotlib.patches as mpatches
    import networkx as nx
    import seaborn as sns
    import numpy as np
    import pandas as pd
    import csv

    df = pd.read_csv('/home/cpsoz/TM-WS-25/TM-Analyse-4/Job-edge.csv')
    df['weight'] = df['weight'].apply(lambda x: x*3)
    Graphtype = nx.Graph()
    G = nx.from_pandas_edgelist(df, edge_attr='weight', create_using=Graphtype)
    widths = nx.get_edge_attributes(G, 'weight') # thikness of edges
    d = nx.degree(G) # nodes degrees
    pos = nx.spring_layout(G,weight='weight', iterations=100)
    nx.draw_networkx_nodes(G,pos=pos,
                         nodelist=G.nodes(),
                         node_size=[(d[v] + 1) * 100 for v in G.nodes()],
                         node_color=[d[v] for v in G.nodes()],
                         cmap=plt.cm.Blues,
                         alpha=0.7)
    nx.draw_networkx_edges(G,pos=pos,
                         edgelist = widths.keys(),
                         width=list(widths.values()),
                         edge_cmap=plt.cm.Blues,
                         arrows=True,
                         arrowstyle='-',
                         connectionstyle="arc3, rad=0.2",
                         alpha=0.6)
    nx.draw_networkx_labels(G, pos=pos,
                          labels=dict(zip(G.nodes(),G.nodes())),
                          font_color='black',
                          font_size=3)
    plt.box(False)
    limits=plt.axis('off')

    plt.savefig('/home/cpsoz/TM-WS-25/TM-Analyse-4/Job_network.pdf', dpi=300, bbox_inches='tight')
    return '/home/cpsoz/TM-WS-25/TM-Analyse-4/Job_network.pdf'
#+end_src

#+RESULTS:
[[file:/home/cpsoz/TM-WS-25/TM-Analyse-4/Job_network.pdf]]

Mit den Knoten und Pfeilen Dateien, die wir hergestellt haben, können wir eine netzwerkartige Vorstellung der Ergebnisse ebenfalls mit Gephi anbieten. Im Vergleich zu Networkx sollen wir dafür die Gephi Anwendung verwenden.
